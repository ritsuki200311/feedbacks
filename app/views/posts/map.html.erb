<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
  <div class="py-8">
    <h1 class="text-3xl font-bold text-gray-900 mb-8">ä½œå“ãƒãƒƒãƒ—</h1>
    
    <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
      <div class="flex flex-col lg:flex-row lg:justify-between lg:items-center mb-6 space-y-4 lg:space-y-0">
        <p class="text-gray-600">
          æŠ•ç¨¿åŒå£«ã®é–¢ä¿‚æ€§ã‚’å¯è¦–åŒ–ã—ãŸãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å›³ã§ã™ã€‚é¡ä¼¼ã—ãŸä½œå“ã¯è¿‘ãã«é…ç½®ã•ã‚Œã€è‡ªç„¶ãªã‚¯ãƒ©ã‚¹ã‚¿ã‚’å½¢æˆã—ã¾ã™ã€‚
        </p>
        <div class="flex flex-col lg:flex-row items-start lg:items-center space-y-2 lg:space-y-0 lg:space-x-6">
          <div class="flex items-center space-x-4">
            <div class="flex items-center">
              <div class="w-3 h-3 bg-blue-500 rounded-full mr-2"></div>
              <span class="text-sm text-gray-600">ä»–ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æŠ•ç¨¿</span>
            </div>
            <div class="flex items-center">
              <div class="w-3 h-3 bg-red-500 rounded-full mr-2"></div>
              <span class="text-sm text-gray-600">ã‚ãªãŸã®æŠ•ç¨¿</span>
            </div>
          </div>
          <!-- è¡¨ç¤ºåˆ¶å¾¡ãƒ‘ãƒãƒ« -->
          <div class="flex flex-col space-y-2 text-xs">
            <div class="flex items-center space-x-2">
              <label for="similarity-threshold" class="text-gray-600 font-medium">é–¢é€£åº¦ãƒ•ã‚£ãƒ«ã‚¿:</label>
              <select id="similarity-threshold" name="similarity-threshold" class="px-2 py-1 border border-gray-300 rounded text-xs" aria-describedby="threshold-description">
                <option value="0.1">ã™ã¹ã¦è¡¨ç¤º (10%+)</option>
                <option value="0.3" selected>æ¨™æº– (30%+)</option>
                <option value="0.5">å¼·ã„é–¢é€£ã®ã¿ (50%+)</option>
                <option value="0.7">éå¸¸ã«å¼·ã„é–¢é€£ (70%+)</option>
              </select>
            </div>
            <!-- ã‚ºãƒ¼ãƒ æƒ…å ±è¡¨ç¤º -->
            <div class="flex items-center space-x-2">
              <span class="text-gray-600 font-medium">ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«:</span>
              <span id="zoom-info" class="px-2 py-1 bg-gray-100 rounded text-xs">ä¿¯ç°è¡¨ç¤º</span>
            </div>
            <div id="threshold-description" class="sr-only">æŠ•ç¨¿é–“ã®é–¢é€£ç·šã‚’è¡¨ç¤ºã™ã‚‹é¡ä¼¼åº¦ã®æœ€å°å€¤ã‚’é¸æŠã§ãã¾ã™</div>
            <div class="text-gray-500">
              <div class="hidden md:block">ğŸ” ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«: ã‚ºãƒ¼ãƒ  | ğŸ–±ï¸ ãƒ›ãƒãƒ¼: è©³ç´° | ğŸ¯ ã‚¯ãƒªãƒƒã‚¯: æŠ•ç¨¿è¡¨ç¤º</div>
              <div class="block md:hidden">ğŸ“± ãƒ”ãƒ³ãƒ: ã‚ºãƒ¼ãƒ  | ğŸ‘† ã‚¿ãƒƒãƒ—: æŠ•ç¨¿è¡¨ç¤º</div>
            </div>
          </div>
        </div>
      </div>
      
      <div id="network-map" class="w-full border border-gray-200 rounded-xl bg-gradient-to-br from-white to-gray-50 shadow-inner" style="height: 600px; min-height: 600px;"></div>
      
      
      <div id="post-details" class="mt-6 p-4 bg-gray-50 rounded-md hidden">
        <h4 class="font-semibold text-gray-900 mb-2">æŠ•ç¨¿è©³ç´°</h4>
        <div id="post-content"></div>
      </div>
    </div>
  </div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>

class PostsMapController {
  constructor() {
    this.currentZoomLevel = 1;  // åˆæœŸã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ï¼ˆä»£è¡¨ä½œå“ã®ã¿ï¼‰
    this.maxZoomLevel = 3;      // æœ€å¤§ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ï¼ˆå…¨ä½œå“è¡¨ç¤ºï¼‰
    this.isGraphInitialized = false; // ã‚°ãƒ©ãƒ•åˆæœŸåŒ–ãƒ•ãƒ©ã‚°
    this.initializeMap();
  }

  async initializeMap() {
    try {
      console.log('Fetching map data...');
      const response = await fetch('<%= posts_map_path %>.json');
      console.log('Response status:', response.status);
      const data = await response.json();
      console.log('Posts data:', data.posts);
      console.log('Number of posts:', data.posts.length);
      
      // ã€Phase 2-Lightã€‘ãƒ¦ãƒ¼ã‚¶ãƒ¼è¡Œå‹•ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
      if (data.current_user_behavior) {
        this.currentUserData = {
          behavior_data: data.current_user_behavior
        };
        console.log('User behavior data loaded:', this.currentUserData.behavior_data);
      }
      
      // é¡ä¼¼åº¦ãƒãƒˆãƒªãƒƒã‚¯ã‚¹ã‚’ä¿å­˜
      if (data.similarity_matrix) {
        this.similarityMatrix = data.similarity_matrix;
        console.log('Similarity matrix loaded:', Object.keys(this.similarityMatrix).length, 'pairs');
      }
      
      // éšå±¤çš„ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
      if (data.hierarchical_clusters) {
        this.hierarchicalClusters = data.hierarchical_clusters;
        console.log('Hierarchical clusters loaded:', this.hierarchicalClusters);
        console.log('Zoom levels available:', Object.keys(this.hierarchicalClusters));
      }
      
      if (!data.posts || data.posts.length === 0) {
        console.warn('No posts found, using dummy data');
        const dummyPosts = [
          { id: 1, title: "ç¾ã—ã„å¤•ç„¼ã‘", user_name: "é¢¨æ™¯å†™çœŸå®¶", comments_count: 2, tags: ["è‡ªç„¶", "å¤•ç„¼ã‘"], comment_sentiments: {positive: 1, strong: 0, unique: 0, gentle: 1}, is_current_user: false, image_url: "https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=400&fit=crop&crop=center" },
          { id: 2, title: "éƒ½å¸‚ã®å¤œæ™¯", user_name: "éƒ½å¸‚å†™çœŸå®¶", comments_count: 3, tags: ["éƒ½å¸‚", "å¤œæ™¯"], comment_sentiments: {positive: 2, strong: 1, unique: 0, gentle: 0}, is_current_user: true, image_url: "https://images.unsplash.com/photo-1449824913935-59a10b8d2000?w=400&h=400&fit=crop&crop=center" },
          { id: 4, title: "èŠ±ç•‘ã®é¢¨æ™¯", user_name: "è‡ªç„¶æ„›å¥½å®¶", comments_count: 4, tags: ["èŠ±", "è‡ªç„¶"], comment_sentiments: {positive: 3, strong: 1, unique: 0, gentle: 2}, is_current_user: false, image_url: "https://images.unsplash.com/photo-1490750967868-88aa4486c946?w=400&h=400&fit=crop&crop=center" },
          { id: 5, title: "å±±ã®çµ¶æ™¯", user_name: "ç™»å±±å†™çœŸå®¶", comments_count: 5, tags: ["å±±", "é¢¨æ™¯"], comment_sentiments: {positive: 4, strong: 0, unique: 1, gentle: 3}, is_current_user: false, image_url: "https://images.unsplash.com/photo-1506197603052-3cc9c3a201bd?w=400&h=400&fit=crop&crop=center" },
          { id: 6, title: "æµ·è¾ºã®å¤•æ—¥", user_name: "æµ·å†™çœŸå®¶", comments_count: 1, tags: ["æµ·", "å¤•æ—¥"], comment_sentiments: {positive: 1, strong: 2, unique: 2, gentle: 0}, is_current_user: false, image_url: "https://images.unsplash.com/photo-1439066615861-d1af74d74000?w=400&h=400&fit=crop&crop=center" },
          { id: 7, title: "æ£®ã®å°é“", user_name: "æ£®æ—å†™çœŸå®¶", comments_count: 3, tags: ["æ£®", "è‡ªç„¶"], comment_sentiments: {positive: 2, strong: 0, unique: 1, gentle: 2}, is_current_user: false, image_url: "https://images.unsplash.com/photo-1441974231531-c6227db76b6e?w=400&h=400&fit=crop&crop=center" },
          { id: 8, title: "æ¡œä¸¦æœ¨", user_name: "æ˜¥å†™çœŸå®¶", comments_count: 6, tags: ["æ¡œ", "æ˜¥"], comment_sentiments: {positive: 5, strong: 0, unique: 0, gentle: 4}, is_current_user: false, image_url: "https://images.unsplash.com/photo-1522383225653-ed111181a951?w=400&h=400&fit=crop&crop=center" }
        ];
        this.renderNetworkGraph(dummyPosts);
        return;
      }
      
      this.allPosts = data.posts;  // å…¨æŠ•ç¨¿ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
      
      // ãƒ‡ãƒãƒƒã‚°: ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ç¢ºèª
      console.log('Sample post data:', this.allPosts[0]);
      console.log('Posts with images:', this.allPosts.filter(p => p.image_url).length);
      console.log('Current user posts:', this.allPosts.filter(p => p.is_current_user).length);
      
      this.renderHierarchicalGraph();
      this.setupZoomControls();
    } catch (error) {
      console.error('ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
    }
  }

  // éšå±¤çš„ã‚°ãƒ©ãƒ•è¡¨ç¤ºã®ãƒ¡ã‚¤ãƒ³ãƒ¡ã‚½ãƒƒãƒ‰
  renderHierarchicalGraph() {
    // åˆå›ã®ã¿å…¨ãƒ‡ãƒ¼ã‚¿ã§ã‚°ãƒ©ãƒ•ã‚’æ§‹ç¯‰
    if (!this.isGraphInitialized) {
      this.renderNetworkGraph(this.allPosts);
      this.isGraphInitialized = true;
    } else {
      // 2å›ç›®ä»¥é™ã¯è¡¨ç¤ºåˆ¶å¾¡ã®ã¿
      this.updateNodeVisibility();
    }
  }

  // ç¾åœ¨ã®ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸæŠ•ç¨¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
  getPostsForCurrentZoom() {
    if (!this.hierarchicalClusters) {
      console.log('No hierarchical clusters, using all posts');
      return this.allPosts; // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    }

    const zoomKey = `zoom_level_${this.currentZoomLevel}`;
    const clusters = this.hierarchicalClusters[zoomKey];
    
    if (!clusters || clusters.length === 0) {
      console.log(`No clusters for ${zoomKey}, using all posts`);
      return this.allPosts;
    }

    let postsToShow = [];
    
    if (this.currentZoomLevel === 1) {
      // ãƒ¬ãƒ™ãƒ«1: ä»£è¡¨ä½œå“ã®ã¿
      postsToShow = clusters.map(cluster => cluster.representative_post).filter(post => post);
    } else if (this.currentZoomLevel === 2) {
      // ãƒ¬ãƒ™ãƒ«2: ä»£è¡¨ä½œå“ + é–¢é€£ä½œå“ï¼ˆä¸€éƒ¨ï¼‰
      clusters.forEach(cluster => {
        if (cluster.representative_post) {
          postsToShow.push(cluster.representative_post);
        }
        if (cluster.related_posts && cluster.related_posts.length > 0) {
          postsToShow.push(...cluster.related_posts.slice(0, 3)); // é–¢é€£ä½œå“ã¯3ã¤ã¾ã§
        }
      });
    } else {
      // ãƒ¬ãƒ™ãƒ«3: ã™ã¹ã¦ã®æŠ•ç¨¿
      postsToShow = this.allPosts;
    }

    // é‡è¤‡ã‚’é™¤å»ï¼ˆIDãƒ™ãƒ¼ã‚¹ï¼‰
    const uniquePosts = postsToShow.filter((post, index, self) => 
      post && post.id && self.findIndex(p => p && p.id === post.id) === index
    );

    console.log(`Zoom Level ${this.currentZoomLevel}: ${uniquePosts.length} posts to display`);
    return uniquePosts;
  }

  // D3ã‚ºãƒ¼ãƒ æ©Ÿèƒ½ã®è¨­å®š
  setupZoomControls() {
    const svg = d3.select("#network-map svg");
    
    this.zoom = d3.zoom()
      .scaleExtent([0.5, 5]) // ã‚ºãƒ¼ãƒ ç¯„å›²
      .on("zoom", (event) => {
        const transform = event.transform;
        
        // ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã‚’ã‚¹ã‚±ãƒ¼ãƒ«ã«å¿œã˜ã¦æ±ºå®š
        let newZoomLevel;
        if (transform.k < 1.5) {
          newZoomLevel = 1; // ä¿¯ç°ï¼ˆä»£è¡¨ä½œå“ã®ã¿ï¼‰
        } else if (transform.k < 3) {
          newZoomLevel = 2; // ä¸­é–“ï¼ˆã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼è¡¨ç¤ºï¼‰
        } else {
          newZoomLevel = 3; // è©³ç´°ï¼ˆå…¨æŠ•ç¨¿è¡¨ç¤ºï¼‰
        }
        
        // ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ãŒå¤‰ã‚ã£ãŸå ´åˆã«è¡¨ç¤ºåˆ¶å¾¡ã®ã¿
        if (newZoomLevel !== this.currentZoomLevel) {
          this.currentZoomLevel = newZoomLevel;
          this.updateZoomInfo();
          this.updateNodeVisibility(); // å†æç”»ã§ã¯ãªãè¡¨ç¤ºåˆ¶å¾¡
        }
        
        // æ—¢å­˜ã®è¦ç´ ã«ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ é©ç”¨
        svg.select("g").attr("transform", transform);
      });
    
    svg.call(this.zoom);
  }
  
  // ã‚ºãƒ¼ãƒ æƒ…å ±ã®æ›´æ–°
  updateZoomInfo() {
    const zoomInfo = document.getElementById('zoom-info');
    if (zoomInfo) {
      const levelTexts = {
        1: 'ä¿¯ç°è¡¨ç¤ºï¼ˆä»£è¡¨ä½œå“ï¼‰',
        2: 'è©³ç´°è¡¨ç¤ºï¼ˆã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ï¼‰',
        3: 'å…¨æŠ•ç¨¿è¡¨ç¤º'
      };
      zoomInfo.textContent = levelTexts[this.currentZoomLevel] || 'ä¿¯ç°è¡¨ç¤º';
    }
  }

  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒãƒ¼ãƒ‰åŠå¾„è¨ˆç®—
  getDefaultRadius(commentsCount = 0) {
    const baseRadius = 12;
    const bonusRadius = Math.min(commentsCount * 2, 20); // æœ€å¤§20pxè¿½åŠ 
    return baseRadius + bonusRadius;
  }

  // ãƒãƒ¼ãƒ‰ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ¶å¾¡ï¼ˆå†æç”»ãªã—ï¼‰
  updateNodeVisibility() {
    if (!this.svg) return;

    const postsToShow = this.getPostsForCurrentZoom();
    const visiblePostIds = new Set(postsToShow.map(p => p.id));

    console.log(`Updating visibility: ${visiblePostIds.size} posts visible`);

    // ãƒãƒ¼ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã®è¡¨ç¤ºåˆ¶å¾¡
    this.svg.selectAll('.node-group')
      .style('opacity', d => visiblePostIds.has(d.id) ? 1 : 0.1)
      .style('pointer-events', d => visiblePostIds.has(d.id) ? 'auto' : 'none');

    // ãƒªãƒ³ã‚¯ã®è¡¨ç¤ºåˆ¶å¾¡
    this.svg.selectAll('line')
      .style('opacity', d => {
        if (!d || !d.source || !d.target) return 0;
        const sourceVisible = visiblePostIds.has(d.source.id || d.source);
        const targetVisible = visiblePostIds.has(d.target.id || d.target);
        return (sourceVisible && targetVisible) ? 0.15 + (d.similarity * 0.25) : 0.02;
      });
  }

  // ã‚°ãƒªãƒƒãƒ‰ç·šã®è¿½åŠ ï¼ˆã‚ºãƒ¼ãƒ å®Ÿæ„Ÿã®ãŸã‚ï¼‰
  addGridLines(container, width, height) {
    const gridGroup = container.append("g")
      .attr("class", "grid-lines")
      .style("opacity", 0.1);
    
    const gridSpacing = 50; // ã‚°ãƒªãƒƒãƒ‰é–“éš”
    
    // ç¸¦ç·š
    for (let x = -width; x <= width * 2; x += gridSpacing) {
      gridGroup.append("line")
        .attr("x1", x)
        .attr("y1", -height)
        .attr("x2", x)
        .attr("y2", height * 2)
        .attr("stroke", "#666666")
        .attr("stroke-width", 0.5);
    }
    
    // æ¨ªç·š
    for (let y = -height; y <= height * 2; y += gridSpacing) {
      gridGroup.append("line")
        .attr("x1", -width)
        .attr("y1", y)
        .attr("x2", width * 2)
        .attr("y2", y)
        .attr("stroke", "#666666")
        .attr("stroke-width", 0.5);
    }
  }

  renderNetworkGraph(posts) {
    console.log('Starting renderNetworkGraph with posts:', posts);
    
    const container = d3.select("#network-map");
    if (container.empty()) {
      console.error('Container #network-map not found for D3');
      return;
    }
    
    container.selectAll("*").remove();

    const width = container.node().offsetWidth || 800;
    const height = container.node().offsetHeight || 600;
    
    // ãƒ¢ãƒã‚¤ãƒ«ã®å ´åˆã¯é¡ä¼¼åº¦é–¾å€¤ã‚’è‡ªå‹•èª¿æ•´
    const isMobile = width < 768;
    const defaultThreshold = isMobile ? 0.5 : 0.3; // ãƒ¢ãƒã‚¤ãƒ«ã§ã¯é«˜ã„é–¾å€¤ã§ã‚¹ãƒƒã‚­ãƒªè¡¨ç¤º
    
    if (isMobile) {
      const thresholdSelect = document.getElementById('similarity-threshold');
      if (thresholdSelect && thresholdSelect.value == '0.3') {
        thresholdSelect.value = '0.5'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’èª¿æ•´
      }
    }
    
    // é«˜ã•ãŒå°ã•ã™ãã‚‹å ´åˆã¯å¼·åˆ¶çš„ã«600pxã«ã™ã‚‹
    const actualHeight = height < 100 ? 600 : height;
    
    console.log('Container dimensions:', width, height);
    console.log('Container node:', container.node());

    const svg = container.append("svg")
      .attr("width", width)
      .attr("height", actualHeight)
      .style("background", "white");
    
    // SVGå‚ç…§ã‚’ä¿å­˜ï¼ˆè¡¨ç¤ºåˆ¶å¾¡ç”¨ï¼‰
    this.svg = svg;
    
    console.log('SVG created:', svg.node());

    // ã‚·ãƒ³ãƒ—ãƒ«ãªdefsï¼ˆå•é¡Œè§£æ±ºã®ãŸã‚è¤‡é›‘ãªèƒŒæ™¯ã‚’ä¸€æ™‚å‰Šé™¤ï¼‰
    const defs = svg.append("defs");

    // ã‚ºãƒ¼ãƒ æ©Ÿèƒ½ã‚’è¨­å®š
    const zoom = d3.zoom()
      .scaleExtent([0.1, 4])
      .on("zoom", (event) => {
        g.attr("transform", event.transform);
      });

    svg.call(zoom);

    // ã‚°ãƒ©ãƒ•è¦ç´ ã®ã‚³ãƒ³ãƒ†ãƒŠ
    const g = svg.append("g");
    
    // ã‚°ãƒªãƒƒãƒ‰ç·šã‚’è¿½åŠ ï¼ˆã‚ºãƒ¼ãƒ å®Ÿæ„Ÿã®ãŸã‚ï¼‰
    this.addGridLines(g, width, actualHeight);
    
    // ãƒ‡ãƒãƒƒã‚°ç”¨: SVGå¢ƒç•Œã‚’å¯è¦–åŒ–ï¼ˆé–‹ç™ºæ™‚ã®ã¿ï¼‰ - ä¸€æ™‚çš„ã«ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
    /*
    svg.append("rect")
      .attr("x", 0)
      .attr("y", 0) 
      .attr("width", width)
      .attr("height", actualHeight)
      .attr("fill", "none")
      .attr("stroke", "#ff0000")
      .attr("stroke-width", 2)
      .attr("stroke-dasharray", "5,5")
      .style("opacity", 0.3);
    
    // ä¸­å¤®ç‚¹ã‚’å¯è¦–åŒ–
    svg.append("circle")
      .attr("cx", width / 2)
      .attr("cy", actualHeight / 2)
      .attr("r", 5)
      .attr("fill", "#ff0000")
      .style("opacity", 0.8);
    */

    // ãƒãƒ¼ãƒ‰ã¨ãƒªãƒ³ã‚¯ãƒ‡ãƒ¼ã‚¿ã®æº–å‚™ï¼ˆç”»åƒãŒã‚ã‚‹æŠ•ç¨¿ã®ã¿ï¼‰
    console.log('All posts:', posts);
    
    if (!posts || posts.length === 0) {
      console.error('No posts data available');
      return;
    }
    
    const nodes = posts
      .map(post => ({
        id: post.id,
        title: post.title,
        body: post.body,
        userName: post.user_name,
        userId: post.user_id,
        isCurrentUser: post.is_current_user || false,
        commentsCount: post.comments_count,
        tags: post.tags || [],
        imageUrl: post.image_url,
        sentiments: post.comment_sentiments || {},
        radius: this.getDefaultRadius(post.comments_count || 0)
      }));

    // åˆæœŸä½ç½®ã‚’è¨­å®š
    nodes.forEach((node, i) => {
      node.x = width / 2 + (Math.random() - 0.5) * 100;
      node.y = height / 2 + (Math.random() - 0.5) * 100;
    });

    console.log('Nodes created:', nodes.length);
    console.log('Node details:', nodes);
    
    if (nodes.length === 0) {
      console.error('No nodes to display!');
      return;
    }
    
    const links = this.calculateSimilarityLinks(nodes, 0.2); // é©åˆ‡ãªé–¾å€¤ã«æˆ»ã™ï¼ˆæœ€å°ä¿è¨¼æ©Ÿèƒ½ãŒã‚ã‚‹ãŸã‚ï¼‰
    console.log('Links created:', links.length);
    console.log('Sample links:', links.slice(0, 3));
    
    // ã‚¯ãƒ©ã‚¹ã‚¿ã‚’æ¤œå‡º
    const clusters = this.detectClusters(nodes, links);
    console.log('Clusters detected:', clusters);

    // åŠ›å­¦ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®è¨­å®š
    const simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id(d => d.id).distance(d => this.calculateLinkDistance(d.similarity)))
      .force("charge", d3.forceManyBody().strength(-100))
      .force("center", d3.forceCenter(width / 2, actualHeight / 2))
      .force("collision", d3.forceCollide().radius(d => (d.radius || 12) + 10))
      .force("x", d3.forceX(width / 2).strength(0.1))  // å¼·åŒ–: 0.05 -> 0.1
      .force("y", d3.forceY(actualHeight / 2).strength(0.1));  // å¼·åŒ–: 0.05 -> 0.1
    
    // ãƒ‡ãƒãƒƒã‚°ç”¨: ä¸­å¤®ã«åŸºæº–ç‚¹ã‚’è¡¨ç¤º
    if (console && console.log) {
      console.log(`SVG center: (${width/2}, ${actualHeight/2})`);
      console.log(`Nodes positions:`, nodes.map(n => `${n.title}: (${n.x}, ${n.y})`));
    }

    // ã‚¯ãƒ©ã‚¹ã‚¿ã‚¨ãƒªã‚¢ã®æç”»ï¼ˆãƒãƒ¼ãƒ‰ã‚ˆã‚Šå…ˆã«æç”»ï¼‰
    const clusterAreas = g.append("g").attr("class", "cluster-areas");
    
    setTimeout(() => {
      this.drawClusterAreas(clusterAreas, clusters, nodes);
    }, 1500); // å°‘ã—çŸ­ç¸®ã—ã¦æ—©ã‚ã«è¡¨ç¤º

    // ã‚ªã‚·ãƒ£ãƒ¬ãªãƒªãƒ³ã‚¯ã‚¹ã‚¿ã‚¤ãƒ«
    const link = g.append("g")
      .selectAll("line")
      .data(links)
      .enter().append("line")
      .attr("stroke", d => this.getLinkColor(d.similarity))
      .attr("stroke-opacity", d => 0.15 + (d.similarity * 0.25))
      .attr("stroke-width", d => Math.max(1, d.similarity * 4)) // ç·šã®å¤ªã•ã‚’å¼·åŒ–: æœ€å°1pxã€æœ€å¤§4px
      .attr("stroke-linecap", "round")
      .on("mouseover", (event, d) => {
        d3.select(event.target)
          .transition().duration(200)
          .attr("stroke-opacity", 0.8)
          .attr("stroke-width", Math.max(2, d.similarity * 6)); // ãƒ›ãƒãƒ¼æ™‚ã®å¤ªã•ã‚‚å¼·åŒ–
        this.showLinkDetails(event, d);
      })
      .on("mouseout", (event, d) => {
        d3.select(event.target)
          .transition().duration(200)
          .attr("stroke-opacity", 0.15 + (d.similarity * 0.25))
          .attr("stroke-width", Math.max(1, d.similarity * 4)); // å…ƒã®å¤ªã•ã«æˆ»ã™æ™‚ã‚‚å¼·åŒ–
        this.hideLinkDetails();
      });

    // ãƒãƒ¼ãƒ‰ã®æç”»
    const nodeGroup = g.append("g")
      .selectAll("g")
      .data(nodes)
      .enter().append("g")
      .attr("class", "node-group")
      .attr("cursor", "pointer");

    // ã‚ªã‚·ãƒ£ãƒ¬ãªãƒãƒ¼ãƒ‰ã‚¹ã‚¿ã‚¤ãƒ«
    const node = nodeGroup.append("circle")
      .attr("r", d => {
        const radius = d.radius || 12; // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å€¤
        console.log(`Node ${d.id} radius: ${radius}`);
        return radius;
      })
      .attr("fill", d => {
        const color = (d.isCurrentUser === true) ? "#ef4444" : "#3b82f6";
        console.log(`Node ${d.id} isCurrentUser: ${d.isCurrentUser}, color: ${color}`);
        return color;
      })
      .attr("stroke", "#ffffff")
      .attr("stroke-width", 3)
      .style("filter", "drop-shadow(0px 2px 4px rgba(0,0,0,0.2))");

    console.log('Node circles created:', node.size());

    // ç”»åƒãŒã‚ã‚‹å ´åˆã®ã‚µãƒ ãƒã‚¤ãƒ«
    const imageNodes = nodeGroup.filter(d => d.imageUrl && d.imageUrl !== null && d.imageUrl !== "");
    console.log(`Image nodes count: ${imageNodes.size()} out of ${nodeGroup.size()}`);
    
    // ãƒ‡ãƒãƒƒã‚°: ç”»åƒURLã‚’ç¢ºèª
    nodeGroup.each(function(d) {
      console.log(`Node ${d.id} imageUrl: ${d.imageUrl}`);
    });
    
    // ç”»åƒç”¨ã®clipPathã‚’å®šç¾©ï¼ˆæ—¢å­˜ã®defsã‚’ä½¿ç”¨ï¼‰
    imageNodes.each(function(d) {
      defs.append("clipPath")
        .attr("id", `clip-${d.id}`)
        .append("circle")
        .attr("r", (d.radius || 12) - 3)
        .attr("cx", 0)
        .attr("cy", 0);
    });

    // ç”»åƒã‚’è¿½åŠ 
    imageNodes.append("image")
      .attr("href", d => d.imageUrl)
      .attr("x", d => -((d.radius || 12) - 3))
      .attr("y", d => -((d.radius || 12) - 3))
      .attr("width", d => ((d.radius || 12) - 3) * 2)
      .attr("height", d => ((d.radius || 12) - 3) * 2)
      .attr("clip-path", d => `url(#clip-${d.id})`)
      .attr("opacity", 1);

    // ãƒãƒ¼ãƒ‰ãƒ©ãƒ™ãƒ«ã¯éè¡¨ç¤ºï¼ˆãƒ›ãƒãƒ¼æ™‚ã®ã¿è¡¨ç¤ºï¼‰

    // ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã¨ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
    nodeGroup.on("click", (event, d) => {
      this.showPostDetails(d);
    });

    // ãƒã‚¦ã‚¹ãƒ›ãƒãƒ¼ã§ã‚¿ã‚¤ãƒˆãƒ«ã‚’è¡¨ç¤º
    nodeGroup.on("mouseover", (event, d) => {
      this.showNodeTooltip(event, d);
    }).on("mouseout", () => {
      this.hideNodeTooltip();
    });

    // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
    simulation.on("tick", () => {
      link
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

      nodeGroup
        .attr("transform", d => `translate(${d.x},${d.y})`);
    });
    
    // SVGã‚’ä¿å­˜ã—ã¦ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã§ä½¿ç”¨
    this.svg = svg;
    this.allLinks = links;
    
    // ãƒ•ã‚£ãƒ«ã‚¿ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹å¾Œã«è¨­å®šï¼‰
    setTimeout(() => {
      this.setupFilterControls();
    }, 500);
  }

  calculateNodeRadius(commentsCount) {
    return Math.max(18, Math.min(35, 18 + commentsCount * 3));
  }

  calculateSimilarityLinks(nodes, threshold = 0.3) {
    const links = [];
    const allSimilarities = []; // å…¨ã¦ã®é¡ä¼¼åº¦ã‚’è¨˜éŒ²

    // ã™ã¹ã¦ã®ãƒšã‚¢ã®é¡ä¼¼åº¦ã‚’è¨ˆç®—
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        const similarity = this.calculateSimilarity(nodes[i], nodes[j]);
        allSimilarities.push({
          source: nodes[i].id,
          target: nodes[j].id,
          similarity: similarity
        });
      }
    }

    // é–¾å€¤ä»¥ä¸Šã®é¡ä¼¼åº¦ã‚’æŒã¤ãƒªãƒ³ã‚¯ã‚’è¿½åŠ 
    allSimilarities.forEach(link => {
      if (link.similarity > threshold) {
        links.push(link);
      }
    });

    // æœ€ä½ä¿è¨¼: ãƒªãƒ³ã‚¯ãŒ2æœ¬æœªæº€ã®å ´åˆã€æœ€ã‚‚é¡ä¼¼åº¦ã®é«˜ã„ãƒšã‚¢ã‚’å¼·åˆ¶è¿½åŠ 
    if (links.length < 2 && allSimilarities.length >= 2) {
      // é¡ä¼¼åº¦é †ã«ã‚½ãƒ¼ãƒˆ
      allSimilarities.sort((a, b) => b.similarity - a.similarity);
      
      // æ—¢ã«è¿½åŠ ã•ã‚Œã¦ã„ãªã„ãƒªãƒ³ã‚¯ã‹ã‚‰æœ€é«˜é¡ä¼¼åº¦ã®ã‚‚ã®ã‚’é¸æŠ
      const existingLinkIds = new Set(links.map(l => `${l.source}_${l.target}`));
      
      for (let i = 0; i < allSimilarities.length && links.length < 2; i++) {
        const candidate = allSimilarities[i];
        const linkId = `${candidate.source}_${candidate.target}`;
        
        if (!existingLinkIds.has(linkId)) {
          links.push(candidate);
          existingLinkIds.add(linkId);
        }
      }
    }

    console.log(`Links created: ${links.length} (minimum guarantee applied: ${links.length < allSimilarities.length ? 'yes' : 'no'})`);
    return links;
  }
  
  // ãƒªãƒ³ã‚¯ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’å‹•çš„ã«åˆ¶å¾¡
  updateLinksVisibility(threshold) {
    if (!this.svg) {
      console.warn('SVG not initialized for updateLinksVisibility');
      return;
    }
    
    // ã‚ˆã‚Šå…·ä½“çš„ã«lineè¦ç´ ã®ã¿ã‚’é¸æŠ
    const links = this.svg.select('g').selectAll('line');
    
    if (links.empty()) {
      console.warn('No links found for visibility update');
      return;
    }
    
    console.log(`Updating visibility for ${links.size()} links with threshold ${threshold}`);
    
    links.transition()
      .duration(300)
      .style('opacity', d => {
        // d.similarityãŒæœªå®šç¾©ã®å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        const similarity = d && d.similarity !== undefined ? d.similarity : 0;
        const opacity = similarity >= threshold ? 0.15 + (similarity * 0.25) : 0;
        console.log(`Link similarity: ${similarity}, threshold: ${threshold}, opacity: ${opacity}`);
        return opacity;
      })
      .style('pointer-events', d => {
        const similarity = d && d.similarity !== undefined ? d.similarity : 0;
        return similarity >= threshold ? 'auto' : 'none';
      });
    
    // çµ±è¨ˆæƒ…å ±ã‚’æ›´æ–°ï¼ˆå®‰å…¨ãªãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼‰
    const linkData = links.data();
    const visibleLinksCount = linkData.filter(d => d && d.similarity !== undefined && d.similarity >= threshold).length;
    this.updateStatsDisplay(visibleLinksCount, linkData.length);
  }

  calculateSimilarity(node1, node2) {
    // ã‚µãƒ¼ãƒãƒ¼å´ã®é¡ä¼¼åº¦ãƒãƒˆãƒªãƒƒã‚¯ã‚¹ã‚’å„ªå…ˆä½¿ç”¨
    if (this.similarityMatrix) {
      const key1 = `${node1.id}_${node2.id}`;
      const key2 = `${node2.id}_${node1.id}`;
      
      if (this.similarityMatrix[key1] !== undefined) {
        return this.similarityMatrix[key1];
      }
      if (this.similarityMatrix[key2] !== undefined) {
        return this.similarityMatrix[key2];
      }
    }
    
    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´è¨ˆç®—
    let similarity = 0;
    let factors = 0;

    // ã‚¿ã‚°ã®é¡ä¼¼åº¦ï¼ˆé‡ã¿ã‚’å¢—åŠ ï¼‰
    const commonTags = node1.tags.filter(tag => node2.tags.includes(tag));
    const totalTags = new Set([...node1.tags, ...node2.tags]).size;
    if (totalTags > 0) {
      similarity += (commonTags.length / totalTags) * 0.4;  // 0.5 -> 0.4 ã«èª¿æ•´
      factors += 0.4;
    }
    
    // ã€æ–°æ©Ÿèƒ½ã€‘ãƒ¦ãƒ¼ã‚¶ãƒ¼è¡Œå‹•ãƒœãƒ¼ãƒŠã‚¹ï¼ˆ10%ã®é‡ã¿ï¼‰
    const userBehaviorBonus = this.calculateUserBehaviorBonus(node1, node2);
    if (userBehaviorBonus > 0) {
      similarity += userBehaviorBonus * 0.1;
      factors += 0.1;
    }

    // ã‚¿ã‚°ã®ã‚«ãƒ†ã‚´ãƒªãƒ¼é¡ä¼¼åº¦ï¼ˆæ–°è¦è¿½åŠ ï¼‰
    const natureTags = ['è‡ªç„¶', 'é¢¨æ™¯', 'å±±', 'æµ·', 'æ£®', 'èŠ±', 'å¤•ç„¼ã‘', 'å¤•æ—¥'];
    const urbanTags = ['éƒ½å¸‚', 'å¤œæ™¯', 'å»ºç‰©', 'è¡—'];
    const seasonTags = ['æ˜¥', 'å¤', 'ç§‹', 'å†¬', 'æ¡œ'];
    
    const isNature1 = node1.tags.some(tag => natureTags.includes(tag));
    const isNature2 = node2.tags.some(tag => natureTags.includes(tag));
    const isUrban1 = node1.tags.some(tag => urbanTags.includes(tag));
    const isUrban2 = node2.tags.some(tag => urbanTags.includes(tag));
    const isSeason1 = node1.tags.some(tag => seasonTags.includes(tag));
    const isSeason2 = node2.tags.some(tag => seasonTags.includes(tag));
    
    if ((isNature1 && isNature2) || (isUrban1 && isUrban2) || (isSeason1 && isSeason2)) {
      similarity += 0.3;
      factors += 0.3;
    }

    // ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆã®é¡ä¼¼åº¦
    const sentiments1 = node1.sentiments;
    const sentiments2 = node2.sentiments;
    let sentimentSimilarity = 0;
    let sentimentFactors = 0;

    ['positive', 'strong', 'unique', 'gentle'].forEach(sentiment => {
      const score1 = sentiments1[sentiment] || 0;
      const score2 = sentiments2[sentiment] || 0;
      if (score1 > 0 || score2 > 0) {
        const maxScore = Math.max(score1, score2, 1);
        sentimentSimilarity += 1 - Math.abs(score1 - score2) / maxScore;
        sentimentFactors += 1;
      }
    });

    if (sentimentFactors > 0) {
      similarity += (sentimentSimilarity / sentimentFactors) * 0.2;
      factors += 0.2;
    }

    // åŸºæœ¬çš„ãªæ¥ç¶šä¿è¨¼ï¼ˆæœ€ä½é™ã®é¡ä¼¼åº¦ï¼‰
    if (factors === 0) {
      similarity = 0.02;
      factors = 1;
    }

    return factors > 0 ? similarity / factors : 0.02;
  }
  
  // ã€Phase 2-Lightã€‘ãƒ¦ãƒ¼ã‚¶ãƒ¼è¡Œå‹•ã«åŸºã¥ããƒœãƒ¼ãƒŠã‚¹è¨ˆç®—
  calculateUserBehaviorBonus(node1, node2) {
    // ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è¡Œå‹•ãƒ‡ãƒ¼ã‚¿ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã®ã¿
    if (!this.currentUserData || !this.currentUserData.behavior_data) {
      return 0;
    }
    
    const behaviorData = this.currentUserData.behavior_data;
    let bonus = 0;
    
    // ã„ã„ã­ã—ãŸæŠ•ç¨¿ã¨ã®é¡ä¼¼æ€§ãƒœãƒ¼ãƒŠã‚¹
    if (behaviorData.liked_tags && behaviorData.liked_tags.length > 0) {
      const likedTags = behaviorData.liked_tags;
      
      // node1, node2ã®ã‚¿ã‚°ãŒã„ã„ã­ã—ãŸã‚¿ã‚°ã¨é‡è¤‡ã™ã‚‹åº¦åˆã„
      const node1LikeMatch = this.calculateTagOverlap(node1.tags, likedTags);
      const node2LikeMatch = this.calculateTagOverlap(node2.tags, likedTags);
      
      // ä¸¡æ–¹ã®æŠ•ç¨¿ãŒå¥½ã¿ã®ã‚¿ã‚°ã‚’å«ã‚€å ´åˆã€ãƒœãƒ¼ãƒŠã‚¹
      if (node1LikeMatch > 0 && node2LikeMatch > 0) {
        bonus += Math.min(node1LikeMatch, node2LikeMatch) * 0.5;
      }
    }
    
    // ã‚³ãƒ¡ãƒ³ãƒˆã—ãŸæŠ•ç¨¿ã¨ã®é¡ä¼¼æ€§ãƒœãƒ¼ãƒŠã‚¹  
    if (behaviorData.commented_tags && behaviorData.commented_tags.length > 0) {
      const commentedTags = behaviorData.commented_tags;
      
      const node1CommentMatch = this.calculateTagOverlap(node1.tags, commentedTags);
      const node2CommentMatch = this.calculateTagOverlap(node2.tags, commentedTags);
      
      if (node1CommentMatch > 0 && node2CommentMatch > 0) {
        bonus += Math.min(node1CommentMatch, node2CommentMatch) * 0.3;
      }
    }
    
    // å«Œã„ãªæŠ•ç¨¿ã¨ã®é¡ä¼¼æ€§ãƒšãƒŠãƒ«ãƒ†ã‚£
    if (behaviorData.disliked_tags && behaviorData.disliked_tags.length > 0) {
      const dislikedTags = behaviorData.disliked_tags;
      
      const node1DislikeMatch = this.calculateTagOverlap(node1.tags, dislikedTags);
      const node2DislikeMatch = this.calculateTagOverlap(node2.tags, dislikedTags);
      
      if (node1DislikeMatch > 0 || node2DislikeMatch > 0) {
        bonus -= Math.max(node1DislikeMatch, node2DislikeMatch) * 0.2;
      }
    }
    
    return Math.max(0, Math.min(1, bonus)); // 0-1ã®ç¯„å›²ã«åˆ¶é™
  }
  
  // ã‚¿ã‚°ã®é‡è¤‡åº¦è¨ˆç®—
  calculateTagOverlap(tags1, tags2) {
    if (!tags1 || !tags2 || tags1.length === 0 || tags2.length === 0) {
      return 0;
    }
    
    const intersection = tags1.filter(tag => tags2.includes(tag)).length;
    const union = new Set([...tags1, ...tags2]).size;
    
    return union > 0 ? intersection / union : 0;
  }

  calculateLinkDistance(similarity) {
    return 80 - (similarity * 40);
  }

  getLinkColor(similarity) {
    // ã‚ˆã‚Šç¾ã—ã„ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ãƒ©ãƒ¼
    if (similarity > 0.7) return "#8b5cf6"; // ç´«
    if (similarity > 0.5) return "#3b82f6"; // é’
    if (similarity > 0.3) return "#06b6d4"; // ã‚·ã‚¢ãƒ³
    if (similarity > 0.1) return "#10b981"; // ç·‘
    return "#64748b"; // ã‚°ãƒ¬ãƒ¼
  }

  getDominantSentimentColor(sentiments) {
    const colors = {
      positive: "#10b981",
      strong: "#ef4444", 
      unique: "#8b5cf6",
      gentle: "#3b82f6"
    };

    let maxSentiment = 'positive';
    let maxCount = sentiments.positive || 0;

    Object.entries(sentiments).forEach(([sentiment, count]) => {
      if (count > maxCount) {
        maxCount = count;
        maxSentiment = sentiment;
      }
    });

    return colors[maxSentiment] || colors.positive;
  }

  detectClusters(nodes, links) {
    // ç°¡å˜ãªã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°: æ¥ç¶šã•ã‚ŒãŸãƒãƒ¼ãƒ‰ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
    const clusters = [];
    const visited = new Set();
    
    nodes.forEach(node => {
      if (!visited.has(node.id)) {
        const cluster = this.findConnectedNodes(node, nodes, links, visited);
        if (cluster.length > 1) {
          clusters.push({
            id: clusters.length,
            nodes: cluster,
            commonTags: this.findCommonTags(cluster),
            dominantSentiment: this.findDominantSentiment(cluster)
          });
        }
      }
    });
    
    return clusters;
  }

  findConnectedNodes(startNode, allNodes, links, visited) {
    const cluster = [startNode];
    const queue = [startNode];
    visited.add(startNode.id);
    
    while (queue.length > 0) {
      const currentNode = queue.shift();
      
      links.forEach(link => {
        let connectedNode = null;
        if (link.source.id === currentNode.id) {
          connectedNode = allNodes.find(n => n.id === link.target.id);
        } else if (link.target.id === currentNode.id) {
          connectedNode = allNodes.find(n => n.id === link.source.id);
        }
        
        if (connectedNode && !visited.has(connectedNode.id)) {
          visited.add(connectedNode.id);
          cluster.push(connectedNode);
          queue.push(connectedNode);
        }
      });
    }
    
    return cluster;
  }

  findCommonTags(nodes) {
    const tagCounts = {};
    nodes.forEach(node => {
      node.tags.forEach(tag => {
        tagCounts[tag] = (tagCounts[tag] || 0) + 1;
      });
    });
    
    return Object.entries(tagCounts)
      .filter(([_, count]) => count > 1)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3)
      .map(([tag, _]) => tag);
  }

  findDominantSentiment(nodes) {
    const sentimentTotals = { positive: 0, strong: 0, unique: 0, gentle: 0 };
    
    nodes.forEach(node => {
      Object.entries(node.sentiments).forEach(([sentiment, count]) => {
        sentimentTotals[sentiment] += count;
      });
    });
    
    return Object.entries(sentimentTotals)
      .sort((a, b) => b[1] - a[1])
      .filter(([_, count]) => count > 0)
      .slice(0, 2)
      .map(([sentiment, _]) => {
        const labels = {
          positive: 'ãƒã‚¸ãƒ†ã‚£ãƒ–',
          strong: 'åŠ›å¼·ã„',
          unique: 'ç‹¬ç‰¹',
          gentle: 'ã‚„ã•ã—ã„'
        };
        return labels[sentiment];
      });
  }

  drawClusterAreas(container, clusters, nodes) {
    clusters.forEach(cluster => {
      const positions = cluster.nodes.map(node => ({ x: node.x, y: node.y }));
      
      if (positions.length >= 2) {
        // ã‚¯ãƒ©ã‚¹ã‚¿ã®ä¸­å¿ƒã¨åŠå¾„ã‚’è¨ˆç®—
        const centroidX = positions.reduce((sum, p) => sum + p.x, 0) / positions.length;
        const centroidY = positions.reduce((sum, p) => sum + p.y, 0) / positions.length;
        
        // æœ€ã‚‚é ã„ç‚¹ã¸ã®è·é›¢ã‚’åŠå¾„ã¨ã—ã¦ä½¿ç”¨ï¼ˆå°‘ã—ä½™è£•ã‚’ã‚‚ãŸã›ã¦ï¼‰
        const maxDistance = Math.max(...positions.map(p => 
          Math.sqrt(Math.pow(p.x - centroidX, 2) + Math.pow(p.y - centroidY, 2))
        )) + 40; // 40px ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°
        
        // è–„ã„å††ã®èƒŒæ™¯ã‚’æç”»
        container.append("circle")
          .attr("cx", centroidX)
          .attr("cy", centroidY)
          .attr("r", maxDistance)
          .attr("fill", "rgba(59, 130, 246, 0.08)") // éå¸¸ã«è–„ã„é’
          .attr("stroke", "rgba(59, 130, 246, 0.2)") // è–„ã„é’ã®å¢ƒç•Œç·š
          .attr("stroke-width", 1)
          .attr("stroke-dasharray", "3,3")
          .attr("opacity", 0.7);
        
        // è¤‡æ•°ã®ãƒãƒ¼ãƒ‰ãŒã‚ã‚‹å ´åˆã®ã¿ãƒ©ãƒ™ãƒ«ã‚’è¡¨ç¤º
        if (cluster.nodes.length > 1) {
          const labelText = this.getClusterLabel(cluster);
          
          container.append("text")
            .attr("x", centroidX)
            .attr("y", centroidY - maxDistance - 10)
            .attr("text-anchor", "middle")
            .attr("font-size", "11px")
            .attr("font-weight", "500")
            .attr("fill", "rgba(59, 130, 246, 0.8)")
            .attr("opacity", 0.8)
            .text(labelText);
        }
      }
    });
  }

  setupFilterControls() {
    const thresholdSelect = document.getElementById('similarity-threshold');
    if (thresholdSelect) {
      thresholdSelect.addEventListener('change', (e) => {
        const threshold = parseFloat(e.target.value);
        this.updateLinksVisibility(threshold);
      });
    }
  }
  
  updateStatsDisplay(visibleCount, totalCount) {
    let statsElement = document.getElementById('network-stats');
    if (!statsElement) {
      // çµ±è¨ˆè¡¨ç¤ºã‚¨ãƒªã‚¢ã‚’å‹•çš„ã«ä½œæˆ
      const networkMap = document.getElementById('network-map');
      statsElement = document.createElement('div');
      statsElement.id = 'network-stats';
      statsElement.className = 'absolute top-2 left-2 bg-white bg-opacity-90 px-2 py-1 rounded text-xs text-gray-600 pointer-events-none';
      networkMap.parentElement.style.position = 'relative';
      networkMap.parentElement.appendChild(statsElement);
    }
    
    statsElement.textContent = `è¡¨ç¤ºä¸­ã®é–¢é€£ç·š: ${visibleCount}/${totalCount}`;
  }

  expandHull(hull, padding) {
    const centroid = d3.polygonCentroid(hull);
    return hull.map(point => {
      const dx = point[0] - centroid[0];
      const dy = point[1] - centroid[1];
      const distance = Math.sqrt(dx * dx + dy * dy);
      const factor = (distance + padding) / distance;
      return [
        centroid[0] + dx * factor,
        centroid[1] + dy * factor
      ];
    });
  }

  getClusterLabel(cluster) {
    const parts = [];
    
    if (cluster.commonTags && cluster.commonTags.length > 0) {
      parts.push(cluster.commonTags.join(' Ã— '));
    }
    
    if (cluster.dominantSentiment && cluster.dominantSentiment.length > 0) {
      parts.push(`${cluster.dominantSentiment.join(' Ã— ')}ãªä½œå“`);
    }
    
    return parts.length > 0 ? parts.join(' | ') : `${cluster.nodes.length}ã¤ã®ä½œå“ã‚°ãƒ«ãƒ¼ãƒ—`;
  }

  showLinkDetails(event, linkData) {
    const tooltip = d3.select("body")
      .append("div")
      .attr("class", "link-tooltip")
      .style("position", "absolute")
      .style("background", "rgba(0, 0, 0, 0.8)")
      .style("color", "white")
      .style("padding", "8px")
      .style("border-radius", "4px")
      .style("font-size", "12px")
      .style("pointer-events", "none")
      .style("z-index", "1000");

    const sourceNode = linkData.source;
    const targetNode = linkData.target;
    const reason = this.getLinkReason(sourceNode, targetNode);
    
    tooltip.html(`
      <strong>æ¥ç¶šç†ç”±</strong><br>
      ${sourceNode.title} â†” ${targetNode.title}<br>
      ${reason}
    `);

    tooltip
      .style("left", (event.pageX + 10) + "px")
      .style("top", (event.pageY - 10) + "px");
  }

  hideLinkDetails() {
    d3.selectAll(".link-tooltip").remove();
  }

  getLinkReason(node1, node2) {
    const reasons = [];
    
    // å…±é€šã‚¿ã‚°ã‚’ãƒã‚§ãƒƒã‚¯
    const tags1 = node1.tags || [];
    const tags2 = node2.tags || [];
    const commonTags = tags1.filter(tag => tags2.includes(tag));
    if (commonTags.length > 0) {
      reasons.push(`å…±é€šã‚¿ã‚°: ${commonTags.join(', ')}`);
    }
    
    // é¡ä¼¼ã—ãŸã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆã‚’ãƒã‚§ãƒƒã‚¯
    const sentiments1 = node1.sentiments || {};
    const sentiments2 = node2.sentiments || {};
    const commonSentiments = [];
    
    Object.keys(sentiments1).forEach(sentiment => {
      if (sentiments1[sentiment] > 0 && sentiments2[sentiment] > 0) {
        const labels = {
          positive: 'ãƒã‚¸ãƒ†ã‚£ãƒ–',
          strong: 'åŠ›å¼·ã„', 
          unique: 'ç‹¬ç‰¹',
          gentle: 'ã‚„ã•ã—ã„'
        };
        commonSentiments.push(labels[sentiment]);
      }
    });
    
    if (commonSentiments.length > 0) {
      reasons.push(`å…±é€šã®é›°å›²æ°—: ${commonSentiments.join(', ')}`);
    }
    
    return reasons.length > 0 ? reasons.join('<br>') : 'é¡ä¼¼ã—ãŸç‰¹å¾´';
  }

  showNodeTooltip(event, nodeData) {
    const tooltip = d3.select("body")
      .append("div")
      .attr("class", "node-tooltip")
      .style("position", "absolute")
      .style("background", "rgba(0, 0, 0, 0.9)")
      .style("color", "white")
      .style("padding", "8px 12px")
      .style("border-radius", "6px")
      .style("font-size", "14px")
      .style("font-weight", "bold")
      .style("pointer-events", "none")
      .style("z-index", "1000")
      .style("box-shadow", "0 4px 6px rgba(0, 0, 0, 0.1)");

    tooltip.html(nodeData.title);

    tooltip
      .style("left", (event.pageX + 10) + "px")
      .style("top", (event.pageY - 10) + "px");
  }

  hideNodeTooltip() {
    d3.selectAll(".node-tooltip").remove();
  }

  showPostDetails(post) {
    const detailsDiv = document.getElementById('post-details');
    const contentDiv = document.getElementById('post-content');
    
    // post.sentimentsã®å®‰å…¨ãªå‡¦ç†
    const sentiments = post.sentiments || {};
    const sentimentText = Object.entries(sentiments)
      .filter(([_, count]) => count > 0)
      .map(([sentiment, count]) => {
        const labels = {
          positive: 'ãƒã‚¸ãƒ†ã‚£ãƒ–',
          strong: 'åŠ›å¼·ã„',
          unique: 'ç‹¬ç‰¹',
          gentle: 'ã‚„ã•ã—ã„'
        };
        return `${labels[sentiment]}: ${count}`;
      })
      .join(', ');

    contentDiv.innerHTML = `
      <div class="space-y-2">
        <h5 class="font-medium">${post.title}</h5>
        <p class="text-sm text-gray-600">ä½œè€…: ${post.userName}</p>
        <p class="text-sm text-gray-600">ã‚³ãƒ¡ãƒ³ãƒˆæ•°: ${post.commentsCount}</p>
        <p class="text-sm text-gray-600">ã‚¿ã‚°: ${(post.tags && post.tags.length > 0) ? post.tags.join(', ') : 'ãªã—'}</p>
        <p class="text-sm text-gray-600">ã‚³ãƒ¡ãƒ³ãƒˆå‚¾å‘: ${sentimentText || 'ãªã—'}</p>
        ${post.body ? `<p class="text-sm mt-2">${post.body.substring(0, 100)}${post.body.length > 100 ? '...' : ''}</p>` : ''}
      </div>
    `;
    
    detailsDiv.classList.remove('hidden');
  }

  drag(simulation) {
    function dragstarted(event) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      event.subject.fx = event.subject.x;
      event.subject.fy = event.subject.y;
    }

    function dragged(event) {
      event.subject.fx = event.x;
      event.subject.fy = event.y;
    }

    function dragended(event) {
      if (!event.active) simulation.alphaTarget(0);
      event.subject.fx = null;
      event.subject.fy = null;
    }

    return d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended);
  }
}

// ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å¾Œã«åˆæœŸåŒ–
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOM loaded, initializing PostsMapController...');
  console.log('D3 version:', d3.version);
  
  const container = document.getElementById('network-map');
  if (!container) {
    console.error('Container #network-map not found');
    return;
  }
  
  console.log('Container found, creating map controller...');
  new PostsMapController();
});
</script>

<style>
  /* ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£å¯¾å¿œ */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œã®å¼·åŒ– */
  @media (max-width: 768px) {
    #network-map {
      height: 500px !important; /* 400px ã‹ã‚‰ 500px ã«å¢—åŠ  */
    }
    
    .max-w-7xl {
      max-width: 100%;
      padding: 0 1rem;
    }
    
    /* ãƒ¢ãƒã‚¤ãƒ«ç”¨ã®è¡¨ç¤ºåˆ¶å¾¡ãƒ‘ãƒãƒ«æœ€é©åŒ– */
    .flex.flex-col.lg\\:flex-row.items-start.lg\\:items-center {
      flex-direction: column;
      align-items: stretch;
      gap: 1rem;
    }
    
    #similarity-threshold {
      width: 100%;
      padding: 0.5rem;
      font-size: 14px;
    }
    
    /* ã‚¿ãƒƒãƒæ“ä½œã‚’æ”¹å–„ */
    select, button {
      min-height: 44px;
      min-width: 44px;
    }
    
    /* ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã‚’ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œ */
    .node-tooltip, .link-tooltip {
      max-width: 280px !important;
      font-size: 12px !important;
    }
  }
  
  @media (max-width: 480px) {
    #network-map {
      height: 400px !important;
    }
    
    /* éå¸¸ã«å°ã•ãªç”»é¢ã§ã¯ç°¡ç´ åŒ– */
    .text-xs {
      font-size: 0.7rem;
    }
    
    /* æ“ä½œèª¬æ˜ã‚’ç°¡ç´ åŒ– */
    .hide-on-small-mobile {
      display: none;
    }
  }
  
  /* ã‚¿ãƒƒãƒãƒ‡ãƒã‚¤ã‚¹ç”¨ã®æ”¹å–„ */
  @media (hover: none) and (pointer: coarse) {
    /* ãƒ›ãƒãƒ¼åŠ¹æœã‚’ç„¡åŠ¹åŒ–ã—ã€ã‚¿ãƒƒãƒç”¨ã«èª¿æ•´ */
    .node-tooltip {
      display: none; /* ãƒ¢ãƒã‚¤ãƒ«ã§ã¯ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã‚’ç„¡åŠ¹åŒ– */
    }
    
    /* ãƒãƒ¼ãƒ‰ã‚’å°‘ã—å¤§ãã */
    circle {
      r: calc(var(--radius) * 1.2) !important;
    }
  }
</style>